[{"D:\\Github\\Personal Projects\\algo-visual\\src\\index.js":"1","D:\\Github\\Personal Projects\\algo-visual\\src\\reportWebVitals.js":"2","D:\\Github\\Personal Projects\\algo-visual\\src\\App.js":"3","D:\\Github\\Personal Projects\\algo-visual\\src\\SortingVisualizer\\SortingVisualizer.jsx":"4","D:\\Github\\Personal Projects\\algo-visual\\src\\sortingAlgorithms\\sortingAlgorithms.js":"5","D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\index.js":"6","D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\reportWebVitals.js":"7","D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\App.js":"8","D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\SortingVisualizer\\SortingVisualizer.jsx":"9","D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\sortingAlgorithms\\sortingAlgorithms.js":"10"},{"size":500,"mtime":1628520004397,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1628520004397,"results":"13","hashOfConfig":"12"},{"size":231,"mtime":1628522974729,"results":"14","hashOfConfig":"12"},{"size":10882,"mtime":1628675201407,"results":"15","hashOfConfig":"12"},{"size":8981,"mtime":1628675108719,"results":"16","hashOfConfig":"12"},{"size":500,"mtime":1628520004397,"results":"17","hashOfConfig":"18"},{"size":362,"mtime":1628520004397,"results":"19","hashOfConfig":"18"},{"size":231,"mtime":1628522974729,"results":"20","hashOfConfig":"18"},{"size":10882,"mtime":1628675201407,"results":"21","hashOfConfig":"18"},{"size":8981,"mtime":1630142689889,"results":"22","hashOfConfig":"18"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},"1yczty8",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"14i6epn",{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44"},"D:\\Github\\Personal Projects\\algo-visual\\src\\index.js",[],["45","46"],"D:\\Github\\Personal Projects\\algo-visual\\src\\reportWebVitals.js",[],"D:\\Github\\Personal Projects\\algo-visual\\src\\App.js",[],"D:\\Github\\Personal Projects\\algo-visual\\src\\SortingVisualizer\\SortingVisualizer.jsx",[],"D:\\Github\\Personal Projects\\algo-visual\\src\\sortingAlgorithms\\sortingAlgorithms.js",["47"],"D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\index.js",[],"D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\reportWebVitals.js",[],"D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\App.js",[],"D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\SortingVisualizer\\SortingVisualizer.jsx",[],"D:\\Github\\Personal Projects\\algorithm-visualizer\\src\\sortingAlgorithms\\sortingAlgorithms.js",["48"],"export function getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n  }\r\n  \r\n  function mergeSortHelper(\r\n    mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n  }\r\n  \r\n  function doMerge(\r\n    mainArray,\r\n    startIdx,\r\n    middleIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n    while (i <= middleIdx && j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, j]);\r\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }\r\n    while (i <= middleIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, i]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, i]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([j, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([j, j]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  //Quicksort algirithm\r\n  export function getQuickSortAnimation(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    if (array === undefined) return array;\r\n    //quicksort(array, 0, array.length-1, animations);\r\n    console.log(quicksortLomuto(array, 0, array.length - 1, animations));\r\n    \r\n    return animations;\r\n  }\r\n\r\n  // First write the swap function, which is just a helper function to swap values of the array.\r\nfunction swap(array, i, j, animations) {\r\n  animations.push([i, j, array[i], array[j], true, 'secondary']);\r\n  animations.push([i, j, array[i], array[j], true, 'primary']);\r\n  var temp = array[i];\r\n  array[i] = array[j];\r\n  array[j] = temp;\r\n}\r\n\r\nfunction quicksortLomuto(array, left, right, animations) {\r\n  // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\r\n  left = left || 0;\r\n  right = right || array.length - 1;\r\n\r\n  var pivot = partitionLomuto(array, left, right, animations);\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'secondary']);\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'primary']);\r\n\r\n  if (left < pivot - 1) {\r\n      quicksortLomuto(array, left, pivot - 1, animations);\r\n  }\r\n\r\n  if (right > pivot) {\r\n      quicksortLomuto(array, pivot - 1, right, animations)\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nfunction partitionLomuto(array, left, right, animations) {\r\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\r\n  var pivot = right;\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'secondary']);\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'primary']);\r\n  var i = left;\r\n\r\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\r\n  for (var j = left; j < right; j++) {\r\n      if (array[j] <= array[pivot]) {\r\n          swap(array, i, j, animations);\r\n          i++\r\n      }else{\r\n        animations.push([i, j, array[i], array[j], false, 'secondary']);\r\n        animations.push([i, j, array[i], array[j], false, 'primary']);\r\n      }\r\n  }\r\n  swap(array, i, j, animations);\r\n  return i;\r\n}\r\n\r\n//another version of the quick sort function that runs at a better runtime but cant be aimated\r\n  /*function quicksort(array, animations) {\r\n    if (array.length <= 1) {\r\n      return array;\r\n    }\r\n  \r\n    var pivot = array[0];\r\n    \r\n    var left = []; \r\n    var right = [];\r\n  \r\n    for (var i = 1; i < array.length; i++) {\r\n      if(array[i] < pivot){\r\n        left.push(array[i])\r\n      }else{\r\n        right.push(array[i])\r\n      }\r\n      //array[i] < pivot ? left.push(array[i]) : right.push(array[i]);\r\n    }\r\n    \r\n    return quicksort(left).concat(pivot, quicksort(right));\r\n  };*/\r\n\r\n\r\n//Bubble Sort Algorithm\r\nexport function getBubbleSortAnimation(array) {\r\n  const animations = [];\r\n    if (array.length <= 1) return array;\r\n    if (array === undefined) return array;\r\n    //quicksort(array, 0, array.length-1, animations);\r\n    console.log(bubbleSort(array, animations));\r\n    \r\n    return animations;\r\n}\r\nlet bubbleSort = (inputArr, animations) => {\r\n  let len = inputArr.length;\r\n  let swapped;\r\n  do {\r\n      swapped = false;\r\n      for (let i = 0; i < len; i++) {\r\n          if (inputArr[i] > inputArr[i + 1]) {\r\n              animations.push([i, i+1, inputArr[i], inputArr[i+1], true, 'secondary']);\r\n              animations.push([i, i+1, inputArr[i], inputArr[i+1], true, 'primary']);\r\n              let tmp = inputArr[i];\r\n              inputArr[i] = inputArr[i + 1];\r\n              inputArr[i + 1] = tmp;\r\n              swapped = true;\r\n          }else{\r\n            if(inputArr[i+1]){\r\n              animations.push([i, i+1, inputArr[i], inputArr[i+1], false, 'secondary']);\r\n              animations.push([i, i+1, inputArr[i], inputArr[i+1], false, 'primary']);\r\n            }else{\r\n              animations.push([i, null, inputArr[i], null, false, 'secondary']);\r\n              animations.push([i, null, inputArr[i], null, false, 'primary']);\r\n            }\r\n            \r\n          }\r\n      }\r\n  } while (swapped);\r\n  return inputArr;\r\n};\r\n\r\n\r\n//Heap Sort Algorithm\r\n\r\nexport function getHeapSortAnimation(array) {\r\n  const animations = [];\r\n    if (array.length <= 1) return array;\r\n    if (array === undefined) return array;\r\n    //quicksort(array, 0, array.length-1, animations);\r\n    console.log(heapSort(array, array.length, animations));\r\n    \r\n    return animations;\r\n}\r\n // main function to do heap sort \r\n const heapSort = (arr, n, animations) => { \r\n  // Build heap (rearrange array) \r\n  for (let i = parseInt(n / 2 - 1); i >= 0; i--) {\r\n      maxHeapify(arr, n, i, animations); \r\n  }\r\n\r\n  // One by one extract an element from heap \r\n  for (let i = n - 1; i >= 0; i--) { \r\n     // Move current root to end \r\n     animations.push([i, 0, arr[i], arr[0], true, 'secondary']);\r\n      animations.push([i, 0, arr[i], arr[0], true, 'primary']);\r\n     let temp = arr[0]; \r\n     arr[0] = arr[i]; \r\n     arr[i] = temp; \r\n\r\n     // call max heapify on the reduced heap \r\n     maxHeapify(arr, i, 0, animations); \r\n  } \r\n}\r\nconst maxHeapify = (arr, n, i, animations) => {\r\n  let largest = i;\r\n  let l = 2 * i + 1; //left child index\r\n  let r = 2 * i + 2; //right child index\r\n  \r\n  //If left child is smaller than root\r\n   if (l < n && arr[l] > arr[largest]) {\r\n         largest = l; \r\n   }\r\n  \r\n   // If right child is smaller than smallest so far \r\n   if (r < n && arr[r] > arr[largest]) {\r\n        largest = r; \r\n   }\r\n  \r\n   // If smallest is not root \r\n   if (largest != i) { \r\n      animations.push([i, largest, arr[i], arr[largest], true, 'secondary']);\r\n      animations.push([i, largest, arr[i], arr[largest], true, 'primary']);\r\n        let temp = arr[i]; \r\n        arr[i] = arr[largest]; \r\n        arr[largest] = temp; \r\n  \r\n      // Recursively heapify the affected sub-tree \r\n      maxHeapify(arr, n, largest, animations); \r\n    } \r\n}\r\n\r\n",{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":255,"column":16,"nodeType":"55","messageId":"56","endLine":255,"endColumn":18},{"ruleId":"53","severity":1,"message":"54","line":255,"column":16,"nodeType":"55","messageId":"56","endLine":255,"endColumn":18},"no-native-reassign",["57"],"no-negated-in-lhs",["58"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]