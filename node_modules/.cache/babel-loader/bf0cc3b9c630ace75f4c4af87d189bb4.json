{"ast":null,"code":"export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, j]);\n\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, i]); // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([j, j]); // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n} //Quicksort algirithm\n\n\nexport function getQuickSortAnimation(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  if (array === undefined) return array; //quicksort(array, 0, array.length-1, animations);\n\n  console.log(quicksortLomuto(array, 0, array.length - 1, animations));\n  return animations;\n} // First write the swap function, which is just a helper function to swap values of the array.\n\nfunction swap(array, i, j, animations) {\n  animations.push([i, j, array[i], array[j], true, 'secondary']);\n  animations.push([i, j, array[i], array[j], true, 'primary']);\n  var temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}\n\nfunction quicksortLomuto(array, left, right, animations) {\n  // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\n  left = left || 0;\n  right = right || array.length - 1;\n  var pivot = partitionLomuto(array, left, right, animations);\n  animations.push([pivot, 'pivot', 0, 0, false, 'secondary']);\n  animations.push([pivot, 'pivot', 0, 0, false, 'primary']);\n\n  if (left < pivot - 1) {\n    quicksortLomuto(array, left, pivot - 1, animations);\n  }\n\n  if (right > pivot) {\n    quicksortLomuto(array, pivot - 1, right, animations);\n  }\n\n  return array;\n}\n\nfunction partitionLomuto(array, left, right, animations) {\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\n  var pivot = right;\n  animations.push([pivot, 'pivot', 0, 0, false, 'secondary']);\n  animations.push([pivot, 'pivot', 0, 0, false, 'primary']);\n  var i = left;\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n\n  for (var j = left; j < right; j++) {\n    if (array[j] <= array[pivot]) {\n      swap(array, i, j, animations);\n      i++;\n    } else {\n      animations.push([i, j, array[i], array[j], false, 'secondary']);\n      animations.push([i, j, array[i], array[j], false, 'primary']);\n    }\n  }\n\n  swap(array, i, j, animations);\n  return i;\n} //another version of the quick sort function that runs at a better runtime but cant be aimated\n\n/*function quicksort(array, animations) {\r\n  if (array.length <= 1) {\r\n    return array;\r\n  }\r\n\r\n  var pivot = array[0];\r\n  \r\n  var left = []; \r\n  var right = [];\r\n\r\n  for (var i = 1; i < array.length; i++) {\r\n    if(array[i] < pivot){\r\n      left.push(array[i])\r\n    }else{\r\n      right.push(array[i])\r\n    }\r\n    //array[i] < pivot ? left.push(array[i]) : right.push(array[i]);\r\n  }\r\n  \r\n  return quicksort(left).concat(pivot, quicksort(right));\r\n};*/\n//Bubble Sort Algorithm\n\n\nexport function getBubbleSortAnimation(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  if (array === undefined) return array; //quicksort(array, 0, array.length-1, animations);\n\n  console.log(bubbleSort(array, animations));\n  return animations;\n}\n\nlet bubbleSort = (inputArr, animations) => {\n  let len = inputArr.length;\n  let swapped;\n\n  do {\n    swapped = false;\n\n    for (let i = 0; i < len; i++) {\n      if (inputArr[i] > inputArr[i + 1]) {\n        animations.push([i, i + 1, inputArr[i], inputArr[i + 1], true, 'secondary']);\n        animations.push([i, i + 1, inputArr[i], inputArr[i + 1], true, 'primary']);\n        let tmp = inputArr[i];\n        inputArr[i] = inputArr[i + 1];\n        inputArr[i + 1] = tmp;\n        swapped = true;\n      } else {\n        if (inputArr[i + 1]) animations.push([i, i + 1, inputArr[i], inputArr[i + 1], false, 'secondary']);\n        animations.push([i, i + 1, inputArr[i], inputArr[i + 1], false, 'primary']);\n      }\n    }\n  } while (swapped);\n\n  return inputArr;\n};","map":{"version":3,"sources":["D:/Github/Personal Projects/algo-visual/src/sortingAlgorithms/sortingAlgorithms.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","push","getQuickSortAnimation","undefined","console","log","quicksortLomuto","swap","temp","left","right","pivot","partitionLomuto","getBubbleSortAnimation","bubbleSort","inputArr","len","swapped","tmp"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n  }\r\n  \r\n  function mergeSortHelper(\r\n    mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n  }\r\n  \r\n  function doMerge(\r\n    mainArray,\r\n    startIdx,\r\n    middleIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n    while (i <= middleIdx && j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, j]);\r\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }\r\n    while (i <= middleIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, i]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, i]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([j, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([j, j]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  //Quicksort algirithm\r\n  export function getQuickSortAnimation(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    if (array === undefined) return array;\r\n    //quicksort(array, 0, array.length-1, animations);\r\n    console.log(quicksortLomuto(array, 0, array.length - 1, animations));\r\n    \r\n    return animations;\r\n  }\r\n\r\n  // First write the swap function, which is just a helper function to swap values of the array.\r\nfunction swap(array, i, j, animations) {\r\n  animations.push([i, j, array[i], array[j], true, 'secondary']);\r\n  animations.push([i, j, array[i], array[j], true, 'primary']);\r\n  var temp = array[i];\r\n  array[i] = array[j];\r\n  array[j] = temp;\r\n}\r\n\r\nfunction quicksortLomuto(array, left, right, animations) {\r\n  // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\r\n  left = left || 0;\r\n  right = right || array.length - 1;\r\n\r\n  var pivot = partitionLomuto(array, left, right, animations);\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'secondary']);\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'primary']);\r\n\r\n  if (left < pivot - 1) {\r\n      quicksortLomuto(array, left, pivot - 1, animations);\r\n  }\r\n\r\n  if (right > pivot) {\r\n      quicksortLomuto(array, pivot - 1, right, animations)\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nfunction partitionLomuto(array, left, right, animations) {\r\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\r\n  var pivot = right;\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'secondary']);\r\n  animations.push([pivot, 'pivot', 0, 0, false, 'primary']);\r\n  var i = left;\r\n\r\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\r\n  for (var j = left; j < right; j++) {\r\n      if (array[j] <= array[pivot]) {\r\n          swap(array, i, j, animations);\r\n          i++\r\n      }else{\r\n        animations.push([i, j, array[i], array[j], false, 'secondary']);\r\n        animations.push([i, j, array[i], array[j], false, 'primary']);\r\n      }\r\n  }\r\n  swap(array, i, j, animations);\r\n  return i;\r\n}\r\n\r\n//another version of the quick sort function that runs at a better runtime but cant be aimated\r\n  /*function quicksort(array, animations) {\r\n    if (array.length <= 1) {\r\n      return array;\r\n    }\r\n  \r\n    var pivot = array[0];\r\n    \r\n    var left = []; \r\n    var right = [];\r\n  \r\n    for (var i = 1; i < array.length; i++) {\r\n      if(array[i] < pivot){\r\n        left.push(array[i])\r\n      }else{\r\n        right.push(array[i])\r\n      }\r\n      //array[i] < pivot ? left.push(array[i]) : right.push(array[i]);\r\n    }\r\n    \r\n    return quicksort(left).concat(pivot, quicksort(right));\r\n  };*/\r\n\r\n\r\n//Bubble Sort Algorithm\r\nexport function getBubbleSortAnimation(array) {\r\n  const animations = [];\r\n    if (array.length <= 1) return array;\r\n    if (array === undefined) return array;\r\n    //quicksort(array, 0, array.length-1, animations);\r\n    console.log(bubbleSort(array, animations));\r\n    \r\n    return animations;\r\n}\r\nlet bubbleSort = (inputArr, animations) => {\r\n  let len = inputArr.length;\r\n  let swapped;\r\n  do {\r\n      swapped = false;\r\n      for (let i = 0; i < len; i++) {\r\n          if (inputArr[i] > inputArr[i + 1]) {\r\n              animations.push([i, i+1, inputArr[i], inputArr[i+1], true, 'secondary']);\r\n              animations.push([i, i+1, inputArr[i], inputArr[i+1], true, 'primary']);\r\n              let tmp = inputArr[i];\r\n              inputArr[i] = inputArr[i + 1];\r\n              inputArr[i + 1] = tmp;\r\n              swapped = true;\r\n          }else{\r\n            if(inputArr[i+1])\r\n            animations.push([i, i+1, inputArr[i], inputArr[i+1], false, 'secondary']);\r\n            animations.push([i, i+1, inputArr[i], inputArr[i+1], false, 'primary']);\r\n          }\r\n      }\r\n  } while (swapped);\r\n  return inputArr;\r\n};"]},"metadata":{},"sourceType":"module"}