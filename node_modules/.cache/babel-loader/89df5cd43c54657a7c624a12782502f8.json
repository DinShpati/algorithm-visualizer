{"ast":null,"code":"export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, j]);\n\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, i]); // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([j, j]); // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n} //Quicksort algirithm\n\n\nexport function getQuickSortAnimation(array) {\n  const animations = []; //quicksort(array, 0, array.length-1, animations);\n\n  console.log(quicksortLomuto(array, animations));\n  return animations;\n} // First write the swap function, which is just a helper function to swap values of the array.\n\nfunction swap(array, i, j) {\n  var temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}\n\nfunction quicksortLomuto(array, left, right) {\n  // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\n  left = left || 0;\n  right = right || array.length - 1;\n  var pivot = partitionLomuto(array, left, right);\n\n  if (left < pivot - 1) {\n    quicksortLomuto(array, left, pivot - 1);\n  }\n\n  if (right > pivot) {\n    quicksortLomuto(array, pivot - 1, right);\n  }\n\n  return array;\n}\n\nfunction partitionLomuto(array, left, right) {\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\n  var pivot = right;\n  var i = left;\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n\n  for (var j = left; j < right; j++) {\n    if (array[j] <= array[pivot]) {\n      swap(array, i, j);\n      i++;\n    }\n  }\n\n  swap(array, i, j);\n  return i;\n}\n/*function quicksort(array, animations) {\r\n  if (array.length <= 1) {\r\n    return array;\r\n  }\r\n\r\n  var pivot = array[0];\r\n  \r\n  var left = []; \r\n  var right = [];\r\n\r\n  for (var i = 1; i < array.length; i++) {\r\n    if(array[i] < pivot){\r\n      left.push(array[i])\r\n    }else{\r\n      right.push(array[i])\r\n    }\r\n    console.log(array)\r\n    //array[i] < pivot ? left.push(array[i]) : right.push(array[i]);\r\n  }\r\n  \r\n  return quicksort(left).concat(pivot, quicksort(right));\r\n};*/\n// First write the swap function, which is just a helper function to swap values of the array.\n\n/* function swap(array, i, j, animations) {\r\n   animations.push([i, j]);\r\n   animations.push([i, j]);\r\n   var temp = array[i];\r\n   array[i] = array[j];\r\n   array[j] = temp;\r\n }\r\n function quicksortHoare(array, left, right, animations) {\r\n   var pivot;\r\n   if(left >= right){\r\n     return;\r\n   }\r\n   if (array.length > 1) {\r\n     pivot = partitionHoare(array, left, right, animations); //index returned from partition\r\n       if (left < pivot - 1) { //more elements on the left side of the pivot\r\n         quicksortHoare(array, left, pivot - 1, animations);\r\n       }\r\n       if (pivot < right) { //more elements on the right side of the pivot\r\n         quicksortHoare(array, pivot, right, animations);\r\n       }\r\n   }\r\n\n   return animations;\r\n}*/\n\n/* Two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the pivot, one smaller, that are in the wrong order relative to each other. The inverted elements are then swapped. \r\nHere the numerical values of left and right is continually getting updated with each inner while loop. But only if the while loop condition gets satisfied. That is, when the while loop condition is unsatisfied, e.g. for the first inner while loop, when array[left] > array[pivot] which means we have found a misplaced pair. \r\nThat is, although the left <= right (which is being made sure by the outer while loop) the actual elements are not sorted. Meaning a left side element is larger in value than the right side element. So, the code execution then jumps out of the inner while loop and goes right in to execute the swap function.\r\n*/\n\n/*function partitionHoare(array, left, right, animations) {\r\n  var pivot = Math.floor((left + right) / 2);\r\n\r\n  while (left < right) {\r\n      while (array[left] < array[pivot]) {\r\n          left++\r\n      }\r\n      while (array[right] > array[pivot]) {\r\n          right--\r\n      }\r\n\r\n      if (left <= right) {\r\n          swap(array, left, right, animations);\r\n          left++\r\n          right--\r\n      }\r\n  }\r\n  return left;\r\n}*/","map":{"version":3,"sources":["D:/Github/Personal Projects/algo-visual/src/sortingAlgorithms/sortingAlgorithms.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","push","getQuickSortAnimation","console","log","quicksortLomuto","swap","temp","left","right","pivot","partitionLomuto"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n  }\r\n  \r\n  function mergeSortHelper(\r\n    mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n  }\r\n  \r\n  function doMerge(\r\n    mainArray,\r\n    startIdx,\r\n    middleIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n    while (i <= middleIdx && j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, j]);\r\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }\r\n    while (i <= middleIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, i]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, i]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([j, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([j, j]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  //Quicksort algirithm\r\n  export function getQuickSortAnimation(array) {\r\n    const animations = [];\r\n    //quicksort(array, 0, array.length-1, animations);\r\n    console.log(quicksortLomuto(array, animations));\r\n    return animations;\r\n  }\r\n\r\n  // First write the swap function, which is just a helper function to swap values of the array.\r\nfunction swap(array, i, j) {\r\n  var temp = array[i];\r\n  array[i] = array[j];\r\n  array[j] = temp;\r\n}\r\n\r\nfunction quicksortLomuto(array, left, right) {\r\n  // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\r\n  left = left || 0;\r\n  right = right || array.length - 1;\r\n\r\n  var pivot = partitionLomuto(array, left, right);\r\n\r\n  if (left < pivot - 1) {\r\n      quicksortLomuto(array, left, pivot - 1);\r\n  }\r\n\r\n  if (right > pivot) {\r\n      quicksortLomuto(array, pivot - 1, right)\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nfunction partitionLomuto(array, left, right) {\r\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\r\n  var pivot = right;\r\n  var i = left;\r\n\r\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\r\n  for (var j = left; j < right; j++) {\r\n      if (array[j] <= array[pivot]) {\r\n          swap(array, i, j);\r\n          i++\r\n      }\r\n  }\r\n  swap(array, i, j);\r\n  return i;\r\n}\r\n\r\n  /*function quicksort(array, animations) {\r\n    if (array.length <= 1) {\r\n      return array;\r\n    }\r\n  \r\n    var pivot = array[0];\r\n    \r\n    var left = []; \r\n    var right = [];\r\n  \r\n    for (var i = 1; i < array.length; i++) {\r\n      if(array[i] < pivot){\r\n        left.push(array[i])\r\n      }else{\r\n        right.push(array[i])\r\n      }\r\n      console.log(array)\r\n      //array[i] < pivot ? left.push(array[i]) : right.push(array[i]);\r\n    }\r\n    \r\n    return quicksort(left).concat(pivot, quicksort(right));\r\n  };*/\r\n\r\n  // First write the swap function, which is just a helper function to swap values of the array.\r\n /* function swap(array, i, j, animations) {\r\n    animations.push([i, j]);\r\n    animations.push([i, j]);\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n  function quicksortHoare(array, left, right, animations) {\r\n    var pivot;\r\n    if(left >= right){\r\n      return;\r\n    }\r\n    if (array.length > 1) {\r\n      pivot = partitionHoare(array, left, right, animations); //index returned from partition\r\n        if (left < pivot - 1) { //more elements on the left side of the pivot\r\n          quicksortHoare(array, left, pivot - 1, animations);\r\n        }\r\n        if (pivot < right) { //more elements on the right side of the pivot\r\n          quicksortHoare(array, pivot, right, animations);\r\n        }\r\n    }\r\n\r\n    return animations;\r\n}*/\r\n/* Two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the pivot, one smaller, that are in the wrong order relative to each other. The inverted elements are then swapped. \r\nHere the numerical values of left and right is continually getting updated with each inner while loop. But only if the while loop condition gets satisfied. That is, when the while loop condition is unsatisfied, e.g. for the first inner while loop, when array[left] > array[pivot] which means we have found a misplaced pair. \r\nThat is, although the left <= right (which is being made sure by the outer while loop) the actual elements are not sorted. Meaning a left side element is larger in value than the right side element. So, the code execution then jumps out of the inner while loop and goes right in to execute the swap function.\r\n*/\r\n/*function partitionHoare(array, left, right, animations) {\r\n  var pivot = Math.floor((left + right) / 2);\r\n\r\n  while (left < right) {\r\n      while (array[left] < array[pivot]) {\r\n          left++\r\n      }\r\n      while (array[right] > array[pivot]) {\r\n          right--\r\n      }\r\n\r\n      if (left <= right) {\r\n          swap(array, left, right, animations);\r\n          left++\r\n          right--\r\n      }\r\n  }\r\n  return left;\r\n}*/"]},"metadata":{},"sourceType":"module"}